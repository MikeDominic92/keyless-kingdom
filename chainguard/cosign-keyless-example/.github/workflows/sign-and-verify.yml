# Keyless Container Image Signing with Cosign
#
# This workflow demonstrates Sigstore/Cosign keyless signing using GitHub's
# OIDC tokens - no stored signing keys required.
#
# Chainguard Relevance: Demonstrates supply chain security patterns aligned
# with Chainguard's mission - key expertise for IT Engineer (Identity/IAM) role.

name: Sign and Verify Container Image

on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]

permissions:
  contents: read
  packages: write
  id-token: write  # Required for OIDC token

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-sign-verify:
    name: Build, Sign, and Verify
    runs-on: ubuntu-latest

    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-ref: ${{ steps.build.outputs.image-ref }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Install Cosign for keyless signing
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.3.0

      # Set up Docker Buildx for multi-platform builds
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Authenticate to GitHub Container Registry
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract metadata for image tagging
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      # Build and push the container image
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Output image reference
      - name: Output image reference
        id: output
        run: |
          echo "digest=${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT
          echo "image-ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT

      # Sign the container image using keyless signing
      # This uses GitHub's OIDC token - no stored keys!
      - name: Sign container image (Keyless)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          echo "Signing image with Sigstore keyless signing..."
          echo "OIDC issuer: https://token.actions.githubusercontent.com"
          echo "Identity: https://github.com/${{ github.repository }}/.github/workflows/sign-and-verify.yml@${{ github.ref }}"

          cosign sign --yes \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}

          echo "Image signed successfully!"

      # Verify the signature
      - name: Verify container signature
        run: |
          echo "Verifying image signature..."

          cosign verify \
            --certificate-identity="https://github.com/${{ github.repository }}/.github/workflows/sign-and-verify.yml@${{ github.ref }}" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}

          echo "Signature verified successfully!"

      # Generate SBOM
      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
          format: spdx-json
          output-file: sbom.spdx.json

      # Attach SBOM as attestation
      - name: Attach SBOM attestation
        run: |
          cosign attest --yes \
            --type spdxjson \
            --predicate sbom.spdx.json \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}

      # Verify SBOM attestation
      - name: Verify SBOM attestation
        run: |
          cosign verify-attestation \
            --type spdxjson \
            --certificate-identity="https://github.com/${{ github.repository }}/.github/workflows/sign-and-verify.yml@${{ github.ref }}" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}

  # Verify in separate job to prove independence
  verify-signature:
    name: Independent Signature Verification
    runs-on: ubuntu-latest
    needs: build-sign-verify

    steps:
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.3.0

      - name: Verify signature from another job
        run: |
          echo "Verifying signature from independent job..."
          echo "This proves the signature is publicly verifiable."

          cosign verify \
            --certificate-identity-regexp="https://github.com/${{ github.repository }}.*" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            ${{ needs.build-sign-verify.outputs.image-ref }}

          echo "Independent verification successful!"

      - name: Display signing certificate
        run: |
          echo "Displaying signing certificate details..."

          cosign verify \
            --certificate-identity-regexp="https://github.com/${{ github.repository }}.*" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            --output json \
            ${{ needs.build-sign-verify.outputs.image-ref }} | jq '.[] | .optional'
